

1、非常重要一点：BinaryTree是<有序树>,“有序”这一特性是由insert()来保证的。
－－－－在有序的基础上insert，需要递归比较，然后插入
－－－－在有序的基础上find()，查询时间：O(log(depth))；若无序查询时间O(n)。
－－－－remove() 因为涉及到find()，因此执行时间也减少了；但是需要考虑删除节点后维持Tree特性。
－－－－insert() size++   ;  remove() size—

2、 接口 Dictionary 是被很多class实现的。
	因为该接口中有所有ADT都设计到的 
	size() / isEmpty() / insert() / find() / remove()这几个基本函数

－－－－ Homework6中的 HashTable <implements> Dictionary
－－－－ Lab10 中的BinaryTree <implements> Dictionary

3、 涉及到了 tree 中递归的思想。

4、
remove我的思路是：
>--- 是rootNode，单独处理；
>---不是rootNode {
>>-----------是其父节点的左孩子 {
>>>---------------------------没有孩子
>>>---------------------------只有左孩子
>>>---------------------------只有右孩子
>>>---------------------------左右孩子都有 {
>>>>-------------------------------------其右孩子有左孩子 {
>>>>>---------------------------------------------------其右孩子的左孩子有右孩子{}
>>>>>---------------------------------------------------其右孩子的左孩子无右孩子{}
>>>>-------------------------------------其右孩子有左孩子}
>>>>-------------------------------------其右孩子无左孩子{}
>>>---------------------------左右孩子都有}
>>-----------是其父节点的左孩子}
>>-----------是其父节点的右孩子{重复绿字部分的分类讨论}
>---不是rootNode  }